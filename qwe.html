<!DOCTYPE html>
<html lang="en" data-theme="classic">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="description" content="Solitaire CC - The ultimate web solitaire experience.">
    <title>Solitaire CC</title>
    <style>
        /* --- THEMES --- */
        :root {
            --card-w: 85px;
            --card-h: 120px;
            --gap: 15px;
            --nav-h: 60px;
            --radius: 8px;
        }

        [data-theme="classic"] { 
            --bg: #2e7d32; --nav-bg: rgba(0,0,0,0.2); --accent: #ffeb3b; --text: #fff;
            --card-back: repeating-linear-gradient(135deg, #1565c0, #1565c0 10px, #1976d2 10px, #1976d2 20px);
        }
        [data-theme="ocean"] { 
            --bg: #0277bd; --nav-bg: rgba(0,0,0,0.3); --accent: #4fc3f7; --text: #e1f5fe;
            --card-back: repeating-linear-gradient(45deg, #00695c, #00695c 10px, #00796b 10px, #00796b 20px);
        }
        [data-theme="midnight"] { 
            --bg: #240b36; --nav-bg: rgba(255,255,255,0.05); --accent: #d500f9; --text: #f3e5f5;
            --card-back: repeating-linear-gradient(135deg, #4a148c, #4a148c 10px, #6a1b9a 10px, #6a1b9a 20px);
        }
        [data-theme="crimson"] { 
            --bg: #880e4f; --nav-bg: rgba(0,0,0,0.25); --accent: #ff8a80; --text: #fce4ec;
            --card-back: repeating-linear-gradient(135deg, #212121, #212121 10px, #424242 10px, #424242 20px);
        }

        @media (max-width: 600px) {
            :root { --card-w: 45px; --card-h: 65px; --gap: 8px; }
            .brand-text { display: none; } 
            .controls button span { display: none; }
            .controls button { padding: 8px !important; }
        }

        body {
            background-color: var(--bg);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 0; height: 100vh;
            display: flex; flex-direction: column;
            overflow: hidden; user-select: none;
            color: var(--text); touch-action: none;
            transition: background-color 0.5s ease;
        }

        /* --- BRANDING --- */
        .brand { 
            font-weight: 900; font-size: 1.5rem; 
            display: flex; align-items: center; gap: 15px; 
            cursor: pointer;
        }
        
        /* Logo Icon - CSS Only */
        .logo-icon {
            position: relative; width: 40px; height: 40px;
            display: flex; align-items: center; justify-content: center;
            font-family: "Times New Roman", serif;
            font-weight: bold; color: var(--accent);
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        .logo-icon::before { content: 'CC'; position: absolute; font-size: 1.2rem; z-index: 2; left: 8px;}
        .logo-icon::after { 
            content: '‚ô£'; position: absolute; 
            font-size: 2.5rem; opacity: 0.3; 
            transform: rotate(15deg); top: -8px; left: 0;
        }

        /* Device-Centered Watermark */
        /* position: fixed ensure it centers on the SCREEN, not just the board container */
        .watermark {
            position: fixed; 
            top: 55%; left: 50%; /* Slightly lower than center to avoid overlapping stock/foundations */
            transform: translate(-50%, -50%);
            font-size: clamp(3rem, 10vw, 8rem); /* Fluid sizing */
            font-weight: 900;
            color: rgba(255,255,255,0.05);
            pointer-events: none; 
            z-index: 0;
            white-space: nowrap;
            font-family: sans-serif;
            letter-spacing: -2px;
        }
        /* --- HEADER --- */
        header {
            height: var(--nav-h); background: var(--nav-bg);
            display: flex; align-items: center; justify-content: space-between;
            padding: 0 20px; z-index: 100; backdrop-filter: blur(5px);
            position: relative;
        }
        
        /* Mobile menu toggle button */
        .mobile-menu-toggle {
            display: none;
            background: none;
            border: none;
            color: var(--text);
            cursor: pointer;
            padding: 8px;
            border-radius: 4px;
            transition: background-color 0.2s;
        }
        .mobile-menu-toggle:hover {
            background: rgba(255,255,255,0.1);
        }
        @media (max-width: 900px) {
            .mobile-menu-toggle {
                display: block;
            }
            .controls {
                display: none;
            }
            .stats {
                margin-right: 10px;
            }
        }
        @media (max-width: 600px) {
            .brand-text {
                display: none;
            }
            .stats {
                font-size: 0.9rem;
                gap: 10px;
            }
            .player-pill span:last-child {
                display: none;
            }
        }
        @media (max-width: 400px) {
            .stats {
                gap: 5px;
            }
            #score, #timer {
                font-size: 0.8rem;
            }
        }
        
        /* Mobile menu overlay */
        .mobile-menu-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            backdrop-filter: blur(10px);
            z-index: 1000;
            display: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        .mobile-menu-overlay.active {
            display: flex;
            opacity: 1;
            animation: fadeIn 0.3s;
        }
        .mobile-menu-content {
            width: 100%;
            max-width: 400px;
            background: var(--nav-bg);
            height: 100%;
            margin-left: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            transform: translateX(100%);
            transition: transform 0.3s ease;
        }
        .mobile-menu-overlay.active .mobile-menu-content {
            transform: translateX(0);
        }
        .mobile-menu-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .mobile-menu-close {
            background: none;
            border: none;
            color: var(--text);
            cursor: pointer;
            padding: 8px;
            border-radius: 4px;
            transition: background-color 0.2s;
        }
        .mobile-menu-close:hover {
            background: rgba(255,255,255,0.1);
        }
        .mobile-menu-stats {
            background: rgba(0,0,0,0.2);
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 30px;
        }
        .mobile-stat {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            font-size: 1.1rem;
        }
        .mobile-controls {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        .mobile-control-btn {
            background: rgba(255,255,255,0.9);
            border: none;
            border-radius: 8px;
            padding: 15px;
            font-size: 1.1rem;
            font-weight: bold;
            color: #333;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 12px;
            transition: all 0.2s;
            text-align: left;
        }
        .mobile-control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        .mobile-control-btn.btn-hint {
            background-color: var(--accent);
            color: #000;
        }
        .mobile-control-btn span {
            font-size: 1.3rem;
        }
.player-pill { 
            background: rgba(0,0,0,0.2); padding: 5px 15px; border-radius: 20px; 
            font-size: 0.9rem; display: flex; align-items: center; gap: 8px; cursor: pointer;
            transition: transform 0.2s; border: 1px solid rgba(255,255,255,0.1);
        }
        .player-pill:hover { transform: scale(1.05); background: rgba(0,0,0,0.3); }
        
        .stats { font-family: monospace; font-size: 1.1rem; opacity: 0.9; display: flex; gap: 15px; align-items: center;}
        .streak-badge { 
            background: #ff5722; color: white; font-size: 0.8rem; 
            padding: 2px 6px; border-radius: 4px; font-weight: bold; 
            display: none; animation: popIn 0.5s;
        }

        .controls { display: flex; gap: 8px; }
        .controls button {
            background: #fff; border: none; padding: 8px 16px;
            border-radius: 6px; cursor: pointer; font-weight: bold;
            color: #333; box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            transition: all 0.2s; display: flex; align-items: center; gap: 5px;
        }
        .controls button:hover { transform: translateY(-2px); }
        .controls button:active { transform: scale(0.95); }
        .btn-hint { background-color: var(--accent) !important; color: #000 !important; }

        /* --- BOARD --- */
        #board {
            flex: 1; padding: 15px; width: 100%; max-width: 1000px;
            margin: 0 auto; display: grid; grid-template-rows: var(--card-h) 1fr;
            gap: 30px; box-sizing: border-box; position: relative; z-index: 10;
        }
        .top-row { display: flex; gap: var(--gap); width: 100%; position: relative; z-index: 2; }
        .spacer { flex: 1; } 
        .tableau-row { display: flex; gap: var(--gap); height: 100%; justify-content: center; z-index: 2;}

        /* --- SLOTS --- */
        .slot { width: var(--card-w); height: var(--card-h); border-radius: var(--radius); position: relative; }
        .empty-grip {
            border: 2px dashed rgba(255,255,255,0.3); background: rgba(0,0,0,0.1);
            display: flex; justify-content: center; align-items: center;
        }
        .slot.occupied { border: none !important; background: none !important; }
        .slot-icon { font-size: 2rem; opacity: 0.3; color: white; pointer-events: none; }

        /* --- TABLEAU --- */
        .tableau-col { position: relative; width: var(--card-w); height: 100%; }
        .tableau-col.empty-col::before {
            content: ''; position: absolute; top: 0; left: 0;
            width: var(--card-w); height: var(--card-h);
            border: 2px dashed rgba(255,255,255,0.25);
            border-radius: var(--radius); background: rgba(0,0,0,0.05); pointer-events: none;
        }

        /* --- CARDS --- */
        .card {
            width: var(--card-w); height: var(--card-h);
            background: white; border-radius: var(--radius);
            position: absolute; box-shadow: 2px 2px 6px rgba(0,0,0,0.2);
            display: flex; flex-direction: column; justify-content: space-between;
            padding: 4px; box-sizing: border-box; font-weight: bold; font-size: 16px;
            z-index: 10; touch-action: none; transition: transform 0.1s; 
        }
        @media (max-width: 600px) { .card { font-size: 12px; padding: 2px; border-radius: 4px; } }

        .card.red { color: #d32f2f; }
        .card.black { color: #212121; }
        .card.back { background: var(--card-back); border: 2px solid #fff; }
        .card.back * { display: none; }

        .c-top { line-height: 0.9; text-align: center; align-self: flex-start; }
        .c-mid { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 2rem; }
        .c-bot { line-height: 0.9; text-align: center; align-self: flex-end; transform: rotate(180deg); }

        .flying-card {
            position: fixed !important; z-index: 9999 !important; pointer-events: none;
            transition: top 0.2s ease-in, left 0.2s ease-in;
            box-shadow: 10px 15px 25px rgba(0,0,0,0.5) !important;
        }
        .drag-active {
            position: fixed !important; z-index: 9999 !important; pointer-events: none;
            width: var(--card-w); height: var(--card-h); transition: transform 0.05s linear;
        }
        .drag-active .card { box-shadow: 15px 20px 30px rgba(0,0,0,0.4); transform: scale(1.05); }

        /* --- HINTS --- */
        .highlight { 
            position: relative; z-index: 100; 
            animation: gentlePulse 1s infinite alternate ease-in-out;
        }
        .card.highlight::after {
            content: ''; position: absolute; top: -3px; left: -3px; right: -3px; bottom: -3px;
            border-radius: 8px; border: 3px solid rgba(255, 255, 255, 0.9);
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.6); pointer-events: none;
        }
        .tableau-col.highlight::after {
            content: ''; position: absolute; top: 0; left: 0;
            width: var(--card-w); height: var(--card-h);
            border-radius: var(--radius);
            border: 3px solid rgba(255, 235, 59, 0.9); 
            box-shadow: 0 0 15px rgba(255, 235, 59, 0.6);
            pointer-events: none; z-index: 50;
        }

        @keyframes gentlePulse { 0% { transform: scale(1); } 100% { transform: scale(1.03); } }

        /* --- MODALS & OVERLAYS --- */
        .modal-overlay {
            position: fixed; top:0; left:0; width:100%; height:100%;
            background: rgba(0,0,0,0.6); display: none;
            justify-content: center; align-items: center; z-index: 10000;
            backdrop-filter: blur(8px); animation: fadeIn 0.3s;
        }
        .modal-content {
            background: #fff; color: #333; padding: 30px; border-radius: 15px;
            width: 90%; max-width: 400px; text-align: center;
            box-shadow: 0 20px 50px rgba(0,0,0,0.3);
            animation: popIn 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        .modal-title { font-size: 2rem; margin-bottom: 10px; font-weight: 900; color: #333; }
        
        .setting-group { margin-bottom: 20px; text-align: left; }
        .setting-label { font-size: 0.9rem; color: #666; margin-bottom: 5px; display: block; font-weight: bold; }
        .input-field { 
            width: 100%; padding: 10px; border: 2px solid #eee; border-radius: 8px; 
            font-size: 1rem; box-sizing: border-box; transition: border 0.2s;
        }
        .input-field:focus { border-color: #2e7d32; outline: none; }
        
        .theme-grid { display: flex; gap: 10px; margin-top: 5px; }
        .theme-btn { 
            width: 40px; height: 40px; border-radius: 50%; border: 3px solid transparent; cursor: pointer; 
            transition: transform 0.2s;
        }
        .theme-btn:hover { transform: scale(1.1); }
        .theme-btn.active { border-color: #333; transform: scale(1.1); }
        .theme-btn[data-t="classic"] { background: #2e7d32; }
        .theme-btn[data-t="ocean"] { background: #0277bd; }
        .theme-btn[data-t="midnight"] { background: #4a148c; }
        .theme-btn[data-t="crimson"] { background: #880e4f; }

        .avatar-grid { display: flex; gap: 10px; justify-content: center; margin-bottom: 15px; }
        .avatar-opt { font-size: 2rem; cursor: pointer; opacity: 0.5; transition: 0.2s; }
        .avatar-opt:hover { transform: scale(1.2); opacity: 1; }
        .avatar-opt.active { opacity: 1; transform: scale(1.2); text-shadow: 0 0 10px rgba(0,0,0,0.2); }

        .toggle-switch {
            position: relative; display: inline-block; width: 50px; height: 26px;
        }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .slider {
            position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0;
            background-color: #ccc; transition: .4s; border-radius: 34px;
        }
        .slider:before {
            position: absolute; content: ""; height: 18px; width: 18px; left: 4px; bottom: 4px;
            background-color: white; transition: .4s; border-radius: 50%;
        }
        input:checked + .slider { background-color: #2e7d32; }
        input:checked + .slider:before { transform: translateX(24px); }

        .modal-btn {
            background: #2e7d32; color: white; border: none; padding: 12px 30px;
            border-radius: 50px; font-size: 1.1rem; font-weight: bold; cursor: pointer;
            margin-top: 10px; width: 100%;
        }

        #win-modal h1 { color: #ffd700; margin-bottom: 5px; }
        #win-player-display { font-size: 1.5rem; color: white; margin-bottom: 20px; }
        #win-player-display span { font-weight: bold; color: #ffd700; }

        #victory-canvas { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10001; }
        
        /* Loading Overlay - Sleek & Minimal */
        #loading-overlay {
            position: fixed; top:0;left:0; width:100%; height:100%; background: var(--bg); color:white;
            display:none; flex-direction:column; justify-content:center; align-items:center; z-index: 20000;
        }
        .loader-icon {
            font-size: 4rem; animation: pulse 1s infinite;
            text-shadow: 0 0 20px rgba(255,255,255,0.5); margin-bottom: 20px;
        }

        /* Pause Overlay */
        #pause-overlay {
            position: fixed; top:0; left:0; width:100%; height:100%;
            background: rgba(0,0,0,0.3); backdrop-filter: blur(8px);
            display: none; flex-direction: column; justify-content: center; align-items: center;
            z-index: 9999; color: white;
        }
        #pause-overlay h2 { font-size: 3rem; margin: 0 0 20px 0; text-shadow: 0 4px 10px rgba(0,0,0,0.3); }

        #btn-auto { display: none !important; }

        @keyframes popIn { from { transform: scale(0.8); opacity: 0; } to { transform: scale(1); opacity: 1; } }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }
    </style>
</head>
<body>
<div class="sr-only" aria-hidden="false" style="position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0,0,0,0); white-space: nowrap; border: 0;">
    <h1>Solitaire CC - Play Free Online Klondike Solitaire</h1>
    <p>Solitaire CC is the best free online solitaire game. Play Classic Klondike Solitaire with no downloads required. Enjoy features like unlimited undo, smart hints, and customizable themes. Works on desktop and mobile.</p>
</div>
<div class="watermark">SOLITAIRE CC ‚ô£</div>
<header>
    <div class="brand" onclick="game.openSettings()">
        <div class="logo-icon"></div>
        <div class="brand-text">SOLITAIRE<span>CC</span></div>
    </div>
    
    <!-- Mobile menu toggle button -->
    <button class="mobile-menu-toggle" id="mobileMenuToggle" aria-label="Open menu">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <line x1="3" y1="12" x2="21" y2="12"></line>
            <line x1="3" y1="6" x2="21" y2="6"></line>
            <line x1="3" y1="18" x2="21" y2="18"></line>
        </svg>
    </button>
    
    <div class="stats">
        <div id="header-profile" class="player-pill" onclick="game.openSettings()" aria-label="Player Profile">
            <span id="header-avatar">üë§</span> <span id="header-name">Player</span>
        </div>
        <span id="score">0</span> pts
        <div id="streak-display" class="streak-badge">üî• 3</div>
        <span id="timer" style="margin-left:10px">00:00</span>
    </div>
    <div class="controls">
        <button onclick="game.togglePause()" aria-label="Pause Game">‚è∏Ô∏è <span>Pause (P)</span></button>
        <button class="btn-hint" onclick="game.hint()" aria-label="Get Hint">üí° <span>Hint (H)</span></button>
        <button onclick="game.undo()" aria-label="Undo Move">‚Ü©Ô∏è <span>Undo (Z)</span></button>
        <button onclick="game.openSettings()" aria-label="Settings">‚öôÔ∏è</button>
        <button onclick="game.init()" aria-label="New Game">‚ú® <span>New (N)</span></button>
    </div>
</header>

<!-- Mobile menu overlay -->
<div id="mobileMenuOverlay" class="mobile-menu-overlay">
    <div class="mobile-menu-content">
        <div class="mobile-menu-header">
            <div class="brand">
                <div class="logo-icon"></div>
                <div class="brand-text">SOLITAIRE<span>CC</span></div>
            </div>
            <button class="mobile-menu-close" id="mobileMenuClose" aria-label="Close menu">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <line x1="18" y1="6" x2="6" y2="18"></line>
                    <line x1="6" y1="6" x2="18" y2="18"></line>
                </svg>
            </button>
        </div>
        <div class="mobile-menu-stats">
            <div id="mobile-profile" class="player-pill" onclick="game.openSettings(); closeMobileMenu();">
                <span id="mobile-avatar">üë§</span> <span id="mobile-name">Player</span>
            </div>
            <div class="mobile-stat">
                <span>Score:</span> <span id="mobile-score">0</span> pts
            </div>
            <div class="mobile-stat">
                <span>Time:</span> <span id="mobile-timer">00:00</span>
            </div>
        </div>
        <div class="mobile-controls">
            <button onclick="game.togglePause(); closeMobileMenu();" class="mobile-control-btn">
                <span>‚è∏Ô∏è</span> Pause Game (P)
            </button>
            <button onclick="game.hint(); closeMobileMenu();" class="mobile-control-btn btn-hint">
                <span>üí°</span> Get Hint (H)
            </button>
            <button onclick="game.undo(); closeMobileMenu();" class="mobile-control-btn">
                <span>‚Ü©Ô∏è</span> Undo Move (Z)
            </button>
            <button onclick="game.openSettings(); closeMobileMenu();" class="mobile-control-btn">
                <span>‚öôÔ∏è</span> Settings
            </button>
            <button onclick="game.init(); closeMobileMenu();" class="mobile-control-btn">
                <span>‚ú®</span> New Game (N)
            </button>
        </div>
    </div>
</div>
<div id="loading-overlay">
    <div class="logo-icon loader-icon"></div>
</div>

<div id="pause-overlay">
    <h2>PAUSED</h2>
    <button class="modal-btn" style="width: auto; padding: 15px 40px;" onclick="game.togglePause()">RESUME</button>
</div>

<div id="board">
    <div class="top-row">
        <div id="stock" class="slot empty-grip" onpointerdown="game.clickStock()" aria-label="Stock Pile"><span class="slot-icon">‚Ü∫</span></div>
        <div id="waste" class="slot" aria-label="Waste Pile"></div>
        <div class="spacer"></div>
        <div id="f0" class="slot empty-grip foundation" data-idx="0" aria-label="Foundation Heart"><span class="slot-icon">‚ô•</span></div>
        <div id="f1" class="slot empty-grip foundation" data-idx="1" aria-label="Foundation Diamond"><span class="slot-icon">‚ô¶</span></div>
        <div id="f2" class="slot empty-grip foundation" data-idx="2" aria-label="Foundation Club"><span class="slot-icon">‚ô£</span></div>
        <div id="f3" class="slot empty-grip foundation" data-idx="3" aria-label="Foundation Spade"><span class="slot-icon">‚ô†</span></div>
    </div>
    <div class="tableau-row" id="tab-container"></div>
</div>

<canvas id="victory-canvas"></canvas>

<div id="settings-modal" class="modal-overlay">
    <div class="modal-content">
        <div class="modal-title">Settings</div>
        <div class="setting-group">
            <label class="setting-label">Profile Avatar</label>
            <div class="avatar-grid" id="avatar-grid">
                <div class="avatar-opt" onclick="game.setAvatar('üë§')">üë§</div>
                <div class="avatar-opt" onclick="game.setAvatar('ü¶ä')">ü¶ä</div>
                <div class="avatar-opt" onclick="game.setAvatar('üëΩ')">üëΩ</div>
                <div class="avatar-opt" onclick="game.setAvatar('ü§†')">ü§†</div>
                <div class="avatar-opt" onclick="game.setAvatar('ü§ñ')">ü§ñ</div>
            </div>
        </div>
        <div class="setting-group">
            <label class="setting-label">Player Name</label>
            <input type="text" id="input-name" class="input-field" placeholder="Enter Name" onchange="game.setName(this.value)">
        </div>
        <div class="setting-group">
            <label class="setting-label">Theme</label>
            <div class="theme-grid">
                <div class="theme-btn" data-t="classic" onclick="game.setTheme('classic')"></div>
                <div class="theme-btn" data-t="ocean" onclick="game.setTheme('ocean')"></div>
                <div class="theme-btn" data-t="midnight" onclick="game.setTheme('midnight')"></div>
                <div class="theme-btn" data-t="crimson" onclick="game.setTheme('crimson')"></div>
            </div>
        </div>
        <div class="setting-group" style="display:flex; justify-content:space-between; align-items:center;">
            <label class="setting-label" style="margin:0">Sound Effects</label>
            <label class="toggle-switch">
                <input type="checkbox" id="sound-toggle" checked onchange="game.toggleSound(this.checked)">
                <span class="slider"></span>
            </label>
        </div>
        <button class="modal-btn" onclick="game.closeSettings()">Save & Close</button>
    </div>
</div>

<div id="win-modal" class="modal-overlay">
    <div class="modal-content" style="background: rgba(0,0,0,0.8); color:white;">
        <h1>VICTORY!</h1>
        <div id="win-player-display">Great job, <span id="win-name">Player</span>!</div>
        <div class="stats" style="justify-content: center; margin-bottom: 20px;">
            Score: <span id="win-score">0</span>
        </div>
        <button class="modal-btn" style="background:#ffd700; color:#333" onclick="game.init()">Play Again</button>
    </div>
</div>

<script>
class AudioSys {
    constructor() { 
        this.ctx = new (window.AudioContext || window.webkitAudioContext)(); 
        this.baseFreq = 300; 
        this.currentStep = 0;
        this.muted = false;
    }
    playTone(freq, type, duration, vol=0.1) {
        if(this.muted) return;
        try {
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.connect(gain); gain.connect(this.ctx.destination);
            osc.type = type; osc.frequency.value = freq;
            gain.gain.setValueAtTime(vol, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
            osc.start(); osc.stop(this.ctx.currentTime + duration);
        } catch(e){}
    }
    playSnap() { this.playTone(400, 'triangle', 0.1, 0.1); }
    playWhoosh() { this.playTone(200, 'sine', 0.2, 0.05); }
    playFanfare() {
        if(this.muted) return;
        const notes = [523.25, 659.25, 783.99, 1046.50, 783.99, 1046.50]; 
        notes.forEach((f, i) => { setTimeout(() => this.playTone(f, 'square', 0.3, 0.1), i * 150); });
    }
    playRisingPing() {
        if(this.muted) return;
        const scale = [1, 1.125, 1.25, 1.33, 1.5, 1.6, 1.875, 2]; 
        let multiplier = scale[this.currentStep % scale.length] * (1 + Math.floor(this.currentStep/scale.length));
        let freq = this.baseFreq * multiplier;
        if(freq > 2000) freq = 2000;
        this.playTone(freq, 'sine', 0.15, 0.1);
        this.currentStep++;
    }
    resetPitch() { this.currentStep = 0; }
}

class FireworkSystem {
    constructor() {
        this.canvas = document.getElementById('victory-canvas');
        this.ctx = this.canvas.getContext('2d');
        this.particles = []; this.active = false;
        this.resize(); window.addEventListener('resize', () => this.resize());
    }
    resize() { this.canvas.width = window.innerWidth; this.canvas.height = window.innerHeight; }
    
    stop() { 
        this.active = false; 
        this.particles = []; 
        this.ctx.clearRect(0,0,this.canvas.width, this.canvas.height); 
    }
    
    start() { this.active = true; this.particles = []; this.loop(); }
    
    createBurst(x, y) {
        const colors = ['#fff', '#ffd700', '#4fc3f7', '#ffeb3b'];
        for(let i=0; i<15; i++) {
            this.particles.push({ x: x, y: y, vx: (Math.random()-0.5)*12, vy: (Math.random()-0.5)*12, color: colors[Math.floor(Math.random()*colors.length)], alpha: 1, grav: 0.2, decay: 0.03 });
        }
        if(!this.active) { this.active = true; this.loop(); }
    }
    createExplosion(x, y) {
        const colors = ['#ffeb3b', '#ff5722', '#4caf50', '#2196f3', '#e91e63', '#fff'];
        for(let i=0; i<40; i++) {
            this.particles.push({ x: x, y: y, vx: (Math.random()-0.5)*10, vy: (Math.random()-0.5)*10, color: colors[Math.floor(Math.random()*colors.length)], alpha: 1, grav: 0.1, decay: 0.015 });
        }
    }
    loop() {
        if(!this.active && this.particles.length === 0) return;
        requestAnimationFrame(() => this.loop());
        this.ctx.clearRect(0,0,this.canvas.width, this.canvas.height); 
        if(document.getElementById('win-modal').style.display === 'flex' && Math.random() < 0.05) {
             this.createExplosion(Math.random()*this.canvas.width, Math.random()*(this.canvas.height*0.7));
        }
        for(let i=this.particles.length-1; i>=0; i--) {
            let p = this.particles[i]; p.x+=p.vx; p.y+=p.vy; p.vy+=p.grav; p.alpha-=p.decay;
            this.ctx.globalAlpha = p.alpha; this.ctx.fillStyle = p.color;
            this.ctx.beginPath(); this.ctx.arc(p.x, p.y, p.decay > 0.02 ? 3 : 4, 0, Math.PI*2); this.ctx.fill();
            if(p.alpha <= 0) this.particles.splice(i, 1);
        }
        this.ctx.globalAlpha = 1;
    }
}

class GameValidator {
    constructor() { this.suits = ['‚ô•', '‚ô¶', '‚ô£', '‚ô†']; }
    isSolvable(initialDeck) {
        let deck = JSON.parse(JSON.stringify(initialDeck));
        let state = { stock: [], waste: [], foundations: [[],[],[],[]], tableau: [[],[],[],[],[],[],[]] };
        let dIdx = 0;
        for(let i=0; i<7; i++) {
            for(let j=0; j<i; j++) { state.tableau[i].push(deck[dIdx++]); }
            let c = deck[dIdx++]; c.flipped = true; state.tableau[i].push(c);
        }
        state.stock = deck.slice(dIdx);
        let moves = 0; let noProgressCount = 0; let limit = 2000;
        while (moves < limit) {
            let moved = false;
            if(this.tryMoveToFoundation(state)) { moved = true; }
            if(!moved && this.tryTableauMove(state)) { moved = true; }
            if(!moved && this.tryWasteToTableau(state)) { moved = true; }
            if(!moved) {
                if(state.stock.length > 0) {
                    const c = state.stock.pop(); c.flipped = true; state.waste.push(c); moved = true;
                } else if(state.waste.length > 0) {
                    state.stock = state.waste.reverse().map(c => ({...c, flipped: false})); state.waste = []; moved = true;
                }
            }
            if(moved) { moves++; noProgressCount = 0; } else { noProgressCount++; if(noProgressCount > 2) break; }
            if(state.foundations.reduce((a,b)=>a+b.length,0) === 52) return true;
        }
        return false;
    }
    tryMoveToFoundation(state) {
        for(let i=0; i<7; i++) {
            if(state.tableau[i].length) {
                let c = state.tableau[i].at(-1); let fIdx = this.suits.indexOf(c.suit); let pile = state.foundations[fIdx]; let top = pile.length ? pile.at(-1) : null;
                if((!top && c.rank===1) || (top && c.rank===top.rank+1)) {
                    state.foundations[fIdx].push(state.tableau[i].pop());
                    if(state.tableau[i].length) state.tableau[i].at(-1).flipped = true;
                    return true;
                }
            }
        }
        if(state.waste.length) {
            let c = state.waste.at(-1); let fIdx = this.suits.indexOf(c.suit); let pile = state.foundations[fIdx]; let top = pile.length ? pile.at(-1) : null;
            if((!top && c.rank===1) || (top && c.rank===top.rank+1)) { state.foundations[fIdx].push(state.waste.pop()); return true; }
        }
        return false;
    }
    tryTableauMove(state) {
        for(let i=0; i<7; i++) {
            if(!state.tableau[i].length) continue;
            let startFlipIdx = state.tableau[i].findIndex(c=>c.flipped);
            if(startFlipIdx === 0 && state.tableau[i][0].rank === 13) continue;
            let card = state.tableau[i][startFlipIdx];
            for(let j=0; j<7; j++) {
                if(i===j) continue; let dest = state.tableau[j]; let top = dest.length ? dest.at(-1) : null;
                if(!top) {
                    if(card.rank === 13 && startFlipIdx > 0) {
                        let stack = state.tableau[i].splice(startFlipIdx); state.tableau[j].push(...stack);
                        if(state.tableau[i].length) state.tableau[i].at(-1).flipped = true; return true;
                    }
                } else {
                    if(card.color !== top.color && card.rank === top.rank - 1) {
                        let stack = state.tableau[i].splice(startFlipIdx); state.tableau[j].push(...stack);
                        if(state.tableau[i].length) state.tableau[i].at(-1).flipped = true; return true;
                    }
                }
            }
        }
        return false;
    }
    tryWasteToTableau(state) {
        if(!state.waste.length) return false;
        let card = state.waste.at(-1);
        for(let j=0; j<7; j++) {
            let dest = state.tableau[j]; let top = dest.length ? dest.at(-1) : null;
            if(!top) { if(card.rank === 13) { state.tableau[j].push(state.waste.pop()); return true; } }
            else { if(card.color !== top.color && card.rank === top.rank - 1) { state.tableau[j].push(state.waste.pop()); return true; } }
        }
        return false;
    }
}

/* --- GAME CORE --- */
class Solitaire {
    constructor() {
        this.suits = ['‚ô•', '‚ô¶', '‚ô£', '‚ô†'];
        this.ranks = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
        this.state = {}; this.history = []; this.dragItem = null;
        this.timer = null; this.seconds = 0; this.score = 0; this.wasteFanSize = 0; 
        this.autoPlaying = false; this.autoCompleteTriggered = false;
        this.lastMoveTime = Date.now();
        this.gameStarted = false;
        this.paused = false;
        
        this.prefs = {
            name: localStorage.getItem('sol_name') || "Player" + Math.floor(Math.random()*1000),
            avatar: localStorage.getItem('sol_avatar') || "üë§",
            theme: localStorage.getItem('sol_theme') || "classic",
            sound: localStorage.getItem('sol_sound') !== 'false',
            streak: parseInt(localStorage.getItem('sol_streak')) || 0
        };

        this.fx = new FireworkSystem();
        this.audio = new AudioSys();
        this.validator = new GameValidator();
        this.handlePointerMove = this.handlePointerMove.bind(this);
        this.handlePointerUp = this.handlePointerUp.bind(this);
        
        document.addEventListener('keydown', (e) => {
            if(this.autoPlaying) return;
            if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z') { e.preventDefault(); this.undo(); }
            if(e.key.toLowerCase() === 'n' || e.key === 'F2') { e.preventDefault(); this.init(); }
            if(e.key.toLowerCase() === 'h' || e.key === ' ') { e.preventDefault(); this.hint(); }
            if(e.key.toLowerCase() === 'p') { e.preventDefault(); this.togglePause(); }
        });

        this.loadPrefs();
        this.init();
    }

    loadPrefs() {
        document.documentElement.setAttribute('data-theme', this.prefs.theme);
        this.audio.muted = !this.prefs.sound;
        this.updateProfileUI();
        if(this.prefs.streak > 0) {
            document.getElementById('streak-display').style.display = 'block';
            document.getElementById('streak-display').innerText = `üî• ${this.prefs.streak}`;
        }
    }

    openSettings() {
        document.getElementById('settings-modal').style.display = 'flex';
        document.getElementById('input-name').value = this.prefs.name;
        document.getElementById('sound-toggle').checked = this.prefs.sound;
        this.updateSettingsUI();
    }
    closeSettings() { document.getElementById('settings-modal').style.display = 'none'; }
    setName(val) { this.prefs.name = val || "Player"; localStorage.setItem('sol_name', this.prefs.name); this.updateProfileUI(); }
    setAvatar(val) { this.prefs.avatar = val; localStorage.setItem('sol_avatar', val); this.updateSettingsUI(); this.updateProfileUI(); }
    setTheme(val) { 
        this.prefs.theme = val; localStorage.setItem('sol_theme', val);
        document.documentElement.setAttribute('data-theme', val); this.updateSettingsUI(); 
    }
    toggleSound(val) { this.prefs.sound = val; localStorage.setItem('sol_sound', val); this.audio.muted = !val; }
    updateSettingsUI() {
        document.querySelectorAll('.theme-btn').forEach(b => b.classList.toggle('active', b.dataset.t === this.prefs.theme));
        document.querySelectorAll('.avatar-opt').forEach(b => b.classList.toggle('active', b.innerText === this.prefs.avatar));
    }
    updateProfileUI() {
        document.getElementById('header-name').innerText = this.prefs.name;
        document.getElementById('header-avatar').innerText = this.prefs.avatar;
    }

    togglePause() {
        if(this.autoPlaying) return;
        if(this.paused) {
            this.paused = false;
            if(this.gameStarted) this.startTimer();
            document.getElementById('pause-overlay').style.display = 'none';
            document.getElementById('board').style.filter = 'none';
        } else {
            this.paused = true;
            this.stopTimer();
            document.getElementById('pause-overlay').style.display = 'flex';
            document.getElementById('board').style.filter = 'blur(5px)';
        }
    }

    init() {
        this.fx.stop();
        this.autoPlaying = false; this.autoCompleteTriggered = false; this.history = [];
        this.score = 0; this.wasteFanSize = 0; this.updateScore(0); 
        this.stopTimer(); this.seconds = 0; document.getElementById('timer').innerText="00:00";
        this.gameStarted = false;
        this.paused = false;
        
        document.getElementById('win-modal').style.display = 'none';
        document.getElementById('loading-overlay').style.display = 'flex';
        this.audio.resetPitch();
        this.lastMoveTime = Date.now();

        setTimeout(() => {
            let deck = this.generateDeck();
            let attempts = 0;
            while(attempts < 500) {
                this.shuffle(deck);
                if(this.validator.isSolvable(deck)) break;
                attempts++;
            }
            this.deal(deck);
            document.getElementById('loading-overlay').style.display = 'none';
            this.render();
        }, 50);
    }

    generateDeck() {
        let deck = [];
        this.suits.forEach(s => { this.ranks.forEach((r, i) => { deck.push({ id: r+s, rank: i+1, val: r, suit: s, color: (s==='‚ô•'||s==='‚ô¶')?'red':'black', flipped: false }); }); });
        return deck;
    }
    shuffle(deck) { for(let i=deck.length-1; i>0; i--) { const j = Math.floor(Math.random() * (i+1)); [deck[i], deck[j]] = [deck[j], deck[i]]; } }
    deal(deck) {
        this.state = { stock: [], waste: [], foundations: [[],[],[],[]], tableau: [[],[],[],[],[],[],[]] };
        let playDeck = JSON.parse(JSON.stringify(deck)); let dIdx = 0;
        for(let i=0; i<7; i++) { for(let j=0; j<i; j++) { this.state.tableau[i].push(playDeck[dIdx++]); } let c = playDeck[dIdx++]; c.flipped = true; this.state.tableau[i].push(c); }
        this.state.stock = playDeck.slice(dIdx);
    }

    calculatePoints(basePoints) {
        const now = Date.now();
        const delta = (now - this.lastMoveTime) / 1000; 
        this.lastMoveTime = now;
        let bonus = 0;
        if(delta < 4) bonus = 10; 
        else if(delta < 8) bonus = 5; 
        return basePoints + bonus;
    }

    updateScore(n) { 
        this.score = Math.max(0, this.score + n); 
        document.getElementById('score').innerText = this.score; 
    }

    checkStartTimer() {
        if(!this.gameStarted && !this.paused) {
            this.gameStarted = true;
            this.startTimer();
        }
    }

    clickStock() {
        if(this.autoPlaying || this.paused) return;
        this.checkStartTimer();
        if (this.state.stock.length === 0) {
            if(this.state.waste.length === 0) return;
            this.saveState();
            this.state.stock = this.state.waste.reverse().map(c => ({...c, flipped: false}));
            this.state.waste = []; this.wasteFanSize = 0;
        } else {
            this.saveState();
            const c = this.state.stock.pop(); c.flipped = true; this.state.waste.push(c); this.wasteFanSize = 1;
        }
        this.render(); this.checkAutoWinCondition();
    }
    startDrag(e, cardData, loc) {
        if(this.autoPlaying || this.paused || !cardData.flipped) return;
        this.checkStartTimer();
        e.preventDefault();
        const el = e.currentTarget; const rect = el.getBoundingClientRect();
        let movingStack = [cardData]; let movingEls = [el]; 
        if(loc.startsWith('tableau')) {
            const [_, cIdx, rIdx] = loc.split('-'); const col = this.state.tableau[cIdx]; const idx = parseInt(rIdx);
            if(idx < col.length - 1) { movingStack = col.slice(idx); let sibling = el.nextElementSibling; while(sibling) { movingEls.push(sibling); sibling = sibling.nextElementSibling; } }
        }
        const ghost = document.createElement('div'); ghost.classList.add('drag-active');
        ghost.style.left = rect.left + 'px'; ghost.style.top = rect.top + 'px';
        movingEls.forEach((domEl) => {
            const clone = domEl.cloneNode(true); const domRect = domEl.getBoundingClientRect();
            clone.style.position = 'absolute'; clone.style.left = '0px'; clone.style.top = (domRect.top - rect.top) + 'px';
            clone.onpointerdown = null; ghost.appendChild(clone); domEl.style.opacity = '0';
        });
        document.body.appendChild(ghost);
        this.dragItem = { originalEls: movingEls, ghost: ghost, stack: movingStack, loc: loc, offsetX: (e.clientX || e.touches[0].clientX) - rect.left, offsetY: (e.clientY || e.touches[0].clientY) - rect.top };
        document.addEventListener('pointermove', this.handlePointerMove); document.addEventListener('pointerup', this.handlePointerUp);
    }
    handlePointerMove(e) {
        if(!this.dragItem) return; e.preventDefault();
        const clientX = e.clientX || e.touches[0].clientX; const clientY = e.clientY || e.touches[0].clientY;
        this.dragItem.ghost.style.left = (clientX - this.dragItem.offsetX) + 'px';
        this.dragItem.ghost.style.top = (clientY - this.dragItem.offsetY) + 'px';
        this.applyMagnet(clientX - this.dragItem.offsetX, clientY - this.dragItem.offsetY);
    }
    applyMagnet(x, y) {
        const cx = x + 40; const cy = y + 60; let closest = null; let minDist = 80;
        this.state.foundations.forEach((_, i) => {
            const el = document.getElementById(`f${i}`); const r = el.getBoundingClientRect();
            const dist = Math.hypot(cx - (r.left+r.width/2), cy - (r.top+r.height/2));
            let isValid = false; const pile = this.state.foundations[i]; const top = pile.length ? pile.at(-1) : null; const moving = this.dragItem.stack[0];
            if (this.dragItem.stack.length === 1 && moving.suit === this.suits[i]) { if ((!top && moving.rank === 1) || (top && moving.rank === top.rank + 1)) isValid = true; }
            if(isValid && dist < 100) { closest = {type:'foundation', idx:i, cx: r.left, cy: r.top}; minDist = 0; }
            else if (dist < 80 && minDist > 0) { closest = {type:'foundation', idx:i, cx: r.left, cy: r.top}; }
        });
        if(minDist > 0) {
            this.state.tableau.forEach((col, i) => {
                if(this.dragItem.loc.startsWith(`tableau-${i}`)) return; 
                const colEl = document.querySelector(`.tableau-col[data-idx="${i}"]`); const cards = colEl.querySelectorAll('.card'); const isEmpty = cards.length === 0;
                let targetRect, targetCx, targetCy;
                if (isEmpty) { targetRect = colEl.getBoundingClientRect(); targetCx = targetRect.left + (targetRect.width / 2); targetCy = targetRect.top + 50; } 
                else { targetRect = cards[cards.length-1].getBoundingClientRect(); targetCx = targetRect.left + (targetRect.width / 2); targetCy = targetRect.top + (targetRect.height / 2); }
                const dist = Math.hypot(cx - targetCx, cy - targetCy);
                if(dist < 80) { let snapY = targetRect.top; if(!isEmpty) snapY += 25; closest = {type:'tableau', idx:i, cx: targetRect.left, cy: snapY}; }
            });
        }
        if(closest) { const tx = closest.cx - x; const ty = closest.cy - y; this.dragItem.ghost.style.transform = `translate(${tx*0.5}px, ${ty*0.5}px)`; this.dragItem.target = closest; } 
        else { this.dragItem.ghost.style.transform = 'none'; this.dragItem.target = null; }
    }
    handlePointerUp(e) {
        document.removeEventListener('pointermove', this.handlePointerMove); document.removeEventListener('pointerup', this.handlePointerUp);
        if(!this.dragItem) return;
        const { target, originalEls, ghost, stack } = this.dragItem; let success = false;
        if(target) {
            const primary = stack[0];
            if(target.type === 'foundation') {
                const pile = this.state.foundations[target.idx]; const top = pile.length ? pile.at(-1) : null;
                if(primary.suit === this.suits[target.idx] && ((!top && primary.rank===1) || (top && primary.rank===top.rank+1))) { this.executeMove(target, stack); success = true; }
            } else if(target.type === 'tableau') {
                const col = this.state.tableau[target.idx]; const top = col.length ? col.at(-1) : null;
                let valid = false; if(!top) valid = true; else if(primary.color !== top.color && primary.rank === top.rank - 1) valid = true;
                if(valid) { this.executeMove(target, stack); success = true; }
            }
        }
        ghost.remove(); if(success) { this.audio.playSnap(); this.render(); this.checkAutoWinCondition(); } else { originalEls.forEach(el => el.style.opacity = '1'); } this.dragItem = null;
    }
    executeMove(target, stack) {
        this.saveState();
        if(this.dragItem.loc === 'waste') { 
            this.state.waste.pop(); 
            // Update wasteFanSize: if waste is now empty, set to 0, otherwise set to number of visible cards (up to 3)
            if(this.state.waste.length === 0) {
                this.wasteFanSize = 0;
            } else {
                this.wasteFanSize = Math.min(3, this.state.waste.length);
            }
        } 
        else if (this.dragItem.loc.startsWith('foundation')) { const [_, fIdx] = this.dragItem.loc.split('-'); this.state.foundations[parseInt(fIdx)].pop(); this.updateScore(-15); } 
        else {
            const [_, cIdx, rIdx] = this.dragItem.loc.split('-'); const col = this.state.tableau[cIdx]; col.splice(parseInt(rIdx), stack.length);
            if(col.length && !col.at(-1).flipped) { col.at(-1).flipped = true; this.updateScore(this.calculatePoints(5)); }
        }
        if(target.type === 'foundation') { this.state.foundations[target.idx].push(stack[0]); this.updateScore(this.calculatePoints(10)); } 
        else { this.state.tableau[target.idx].push(...stack); this.updateScore(this.calculatePoints(5)); }
    }
    render() {
        document.getElementById('stock').innerHTML = this.state.stock.length ? `<div class="card back" style="top:0;left:0"></div>` : `<span class="slot-icon">‚Ü∫</span>`;
        const wasteEl = document.getElementById('waste'); wasteEl.innerHTML = '';
        if(this.state.waste.length > 0) {
            const count = Math.min(3, this.state.waste.length); const start = this.state.waste.length - count;
            this.state.waste.slice(start).forEach((c, i, arr) => {
                const isTop = (i === arr.length-1); const el = this.createCard(c, `waste-${this.state.waste.length - count + i}`);
                el.style.left = (i * 12) + 'px'; el.style.top = '0px';
                if(isTop) el.onpointerdown = (e) => this.startDrag(e, c, 'waste'); else { el.style.filter = "brightness(85%)"; el.style.pointerEvents = "none"; }
                wasteEl.appendChild(el);
            });
        } else {
            wasteEl.classList.remove('occupied'); wasteEl.classList.add('empty-grip');
        }
        this.state.foundations.forEach((pile, i) => {
            const el = document.getElementById(`f${i}`);
            if(pile.length > 0) { el.classList.add('occupied'); el.classList.remove('empty-grip'); } else { el.classList.remove('occupied'); el.classList.add('empty-grip'); }
            el.innerHTML = pile.length === 0 ? `<span class="slot-icon">${this.suits[i]}</span>` : '';
            if(pile.length) {
                const c = pile.at(-1); const cardEl = this.createCard(c, `foundation-${i}`);
                cardEl.style.top='0'; cardEl.style.left='0'; cardEl.onpointerdown = (e) => this.startDrag(e, c, `foundation-${i}`);
                el.appendChild(cardEl);
            }
        });
        const tab = document.getElementById('tab-container'); tab.innerHTML = '';
        this.state.tableau.forEach((col, i) => {
            const colEl = document.createElement('div'); colEl.className = 'tableau-col';
            if(col.length===0) colEl.classList.add('empty-col'); colEl.dataset.idx = i;
            let offset = 35; if(col.length > 8) offset = 30; if(col.length > 12) offset = 25;
            col.forEach((c, idx) => {
                const cardEl = this.createCard(c, `tableau-${i}-${idx}`); cardEl.style.top = (idx * offset) + 'px';
                if(c.flipped) cardEl.onpointerdown = (e) => this.startDrag(e, c, `tableau-${i}-${idx}`);
                colEl.appendChild(cardEl);
            });
            tab.appendChild(colEl);
        });
    }
    createCard(c, loc) {
        const div = document.createElement('div');
        if(!c.flipped) { div.className = 'card back'; return div; }
        div.className = `card ${c.color}`; div.dataset.loc = loc;
        div.innerHTML = `<div class="c-top">${c.val}<br>${c.suit}</div><div class="c-mid">${c.suit}</div><div class="c-bot">${c.val}<br>${c.suit}</div>`;
        return div;
    }

    checkAutoWinCondition() {
        const allTableauFlipped = this.state.tableau.every(col => col.every(c => c.flipped));
        const stockEmpty = this.state.stock.length === 0;
        const wasteEmpty = this.state.waste.length === 0;
        const alreadyWon = this.state.foundations.reduce((a,b)=>a+b.length,0) === 52;
        if (alreadyWon) { 
            this.win(); 
        } else if(allTableauFlipped && stockEmpty && wasteEmpty) { 
            if(!this.autoCompleteTriggered) { this.autoCompleteTriggered = true; this.startAutoComplete(); }
        }
    }

    async startAutoComplete() {
        this.autoPlaying = true;
        this.audio.resetPitch();
        while(true) {
            let bestMove = null; let lowestRank = 14;
            for(let i=0; i<7; i++) {
                if(this.state.tableau[i].length) {
                    const c = this.state.tableau[i].at(-1); const fIdx = this.suits.indexOf(c.suit); const pile = this.state.foundations[fIdx]; const top = pile.length ? pile.at(-1) : null;
                    if((!top && c.rank===1) || (top && c.rank===top.rank+1)) {
                        if(c.rank < lowestRank) { lowestRank = c.rank; bestMove = { type:'tableau', idx: i, card: c, fIdx: fIdx }; }
                    }
                }
            }
            if(bestMove) await this.animateAutoMove(bestMove); else break;
            if(this.state.foundations.reduce((a,b)=>a+b.length,0) === 52) break;
        }
        this.win();
    }

    animateAutoMove(move) {
        return new Promise(resolve => {
            let sourceCardEl = document.querySelector(`[data-loc="tableau-${move.idx}-${this.state.tableau[move.idx].length-1}"]`);
            this.state.tableau[move.idx].pop();
            if(!sourceCardEl) { resolve(); return; }
            const startRect = sourceCardEl.getBoundingClientRect(); const targetEl = document.getElementById(`f${move.fIdx}`); const targetRect = targetEl.getBoundingClientRect();
            const flyEl = sourceCardEl.cloneNode(true); flyEl.classList.add('flying-card');
            flyEl.style.left = startRect.left + 'px'; flyEl.style.top = startRect.top + 'px';
            document.body.appendChild(flyEl);
            this.state.foundations[move.fIdx].push(move.card);
            flyEl.getBoundingClientRect(); flyEl.style.left = targetRect.left + 'px'; flyEl.style.top = targetRect.top + 'px';
            this.audio.playWhoosh();
            setTimeout(() => { this.audio.playRisingPing(); this.fx.createBurst(targetRect.left + 40, targetRect.top + 60); flyEl.remove(); this.render(); resolve(); }, 100); 
        });
    }

    win() {
        this.stopTimer();
        this.audio.playFanfare();
        this.prefs.streak++;
        localStorage.setItem('sol_streak', this.prefs.streak);
        document.getElementById('win-name').innerText = this.prefs.name;
        document.getElementById('win-score').innerText = this.score;
        document.getElementById('win-modal').style.display = 'flex';
        this.fx.start(); 
    }

    saveState() { const snap = JSON.parse(JSON.stringify(this.state)); snap.fanSize = this.wasteFanSize; this.history.push(snap); if(this.history.length>20) this.history.shift(); }
    undo() { 
        if(this.history.length && !this.autoPlaying && !this.paused){ 
            const snap = this.history.pop(); 
            const oldState = JSON.parse(JSON.stringify(this.state));
            this.state = JSON.parse(JSON.stringify(snap));
            this.wasteFanSize = snap.fanSize;
            
            // Restore score penalties: +15 for foundation removal, +5 for card flip penalty
            let scoreRestore = 5;
            
            // Check if a card was removed from foundation (undo of foundation move adds points back)
            for(let i = 0; i < 4; i++) {
                if(oldState.foundations[i].length > this.state.foundations[i].length) {
                    scoreRestore += 15;
                }
            }
            
            this.updateScore(scoreRestore); 
            this.render(); 
        } 
    }
    
    hint() {
        if(this.autoPlaying || this.paused) return;
        this.updateScore(-20); 
        document.querySelectorAll('.highlight').forEach(e=>e.classList.remove('highlight'));
        const highlight = (sel1, sel2) => {
            document.querySelector(sel1)?.classList.add('highlight'); 
            document.querySelector(sel2)?.classList.add('highlight');
            setTimeout(()=>document.querySelectorAll('.highlight').forEach(e=>e.classList.remove('highlight')), 1500); 
            return true;
        };
        const canMoveToFoundation = (c) => {
            const fIdx = this.suits.indexOf(c.suit); const top = this.state.foundations[fIdx].length ? this.state.foundations[fIdx].at(-1) : null;
            return (!top && c.rank===1) || (top && c.rank===top.rank+1);
        };
        const canMoveToTableau = (c, destCol) => {
            const top = destCol.length ? destCol.at(-1) : null; if(!top) return true; return c.color !== top.color && c.rank === top.rank - 1;
        };
        // 1. Foundation
        for(let i=0; i<7; i++) {
            if(this.state.tableau[i].length) { const c = this.state.tableau[i].at(-1); if(canMoveToFoundation(c)) return highlight(`.tableau-col[data-idx="${i}"] .card:last-child`, `#f${this.suits.indexOf(c.suit)}`); }
        }
        if(this.state.waste.length) { const c = this.state.waste.at(-1); if(canMoveToFoundation(c)) return highlight('#waste .card:last-child', `#f${this.suits.indexOf(c.suit)}`); }
        // 2. Tableau
        for(let i=0; i<7; i++) {
            const srcCol = this.state.tableau[i]; if(!srcCol.length) continue; const flipIdx = srcCol.findIndex(c => c.flipped); const cardToMove = srcCol[flipIdx];
            if (flipIdx === 0 && cardToMove.rank === 13) { /* Ignore King on empty */ }
            else {
                for(let j=0; j<7; j++) { 
                    if(i === j) continue; const destCol = this.state.tableau[j];
                    if(canMoveToTableau(cardToMove, destCol)) {
                        const targetSel = destCol.length > 0 ? `.tableau-col[data-idx="${j}"] .card:last-child` : `.tableau-col[data-idx="${j}"]`; 
                        return highlight(`[data-loc="tableau-${i}-${flipIdx}"]`, targetSel); 
                    }
                }
            }
        }
        // 3. Waste
        if(this.state.waste.length) { 
            const c = this.state.waste.at(-1); 
            for(let i=0; i<7; i++) { 
                if(canMoveToTableau(c, this.state.tableau[i])) {
                    const destCol = this.state.tableau[i]; const targetSel = destCol.length > 0 ? `.tableau-col[data-idx="${i}"] .card:last-child` : `.tableau-col[data-idx="${i}"]`;
                    return highlight('#waste .card:last-child', targetSel); 
                }
            } 
        }
        if(this.state.stock.length > 0) { document.getElementById('stock').classList.add('highlight'); setTimeout(()=>document.getElementById('stock').classList.remove('highlight'), 1000); }
    }

    startTimer() { this.stopTimer(); this.timer = setInterval(()=>{ this.seconds++; const m=Math.floor(this.seconds/60).toString().padStart(2,'0'); const s=(this.seconds%60).toString().padStart(2,'0'); document.getElementById('timer').innerText=`${m}:${s}`; }, 1000); }
    stopTimer() { if(this.timer) clearInterval(this.timer); }
    resetTimer() { this.stopTimer(); this.seconds=0; document.getElementById('timer').innerText="00:00"; }
}
const game = new Solitaire();

// Initialize mobile menu after game is created
document.addEventListener('DOMContentLoaded', function() {
    initMobileMenu();
});
</script>
</body>
</html>